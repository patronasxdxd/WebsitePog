import {
  ADAPTER_STATUS,
  BaseAdapter,
  WalletLoginError,
  checkIfTokenIsExpired,
  clearToken,
  getSavedToken,
  init_base_esm,
  saveToken,
  signChallenge,
  verifySignedChallenge
} from "./chunk-4CWOH7XN.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-JZQ37OGZ.js";

// ../node_modules/@web3auth/base-solana-adapter/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "../node_modules/@web3auth/base-solana-adapter/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// ../node_modules/@web3auth/base-solana-adapter/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "../node_modules/@web3auth/base-solana-adapter/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// ../node_modules/@web3auth/base-solana-adapter/dist/baseSolanaAdapter.esm.js
var import_bs58, BaseSolanaAdapter;
var init_baseSolanaAdapter_esm = __esm({
  "../node_modules/@web3auth/base-solana-adapter/dist/baseSolanaAdapter.esm.js"() {
    init_base_esm();
    import_bs58 = __toESM(require_bs58());
    BaseSolanaAdapter = class extends BaseAdapter {
      async authenticateUser() {
        var _this$chainConfig;
        if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId))
          throw WalletLoginError.notConnectedError();
        const {
          chainNamespace,
          chainId
        } = this.chainConfig;
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
        const accounts = await this.provider.request({
          method: "getAccounts"
        });
        if (accounts && accounts.length > 0) {
          const existingToken = getSavedToken(accounts[0], this.name);
          if (existingToken) {
            const isExpired = checkIfTokenIsExpired(existingToken);
            if (!isExpired) {
              return {
                idToken: existingToken
              };
            }
          }
          const payload = {
            domain: window.location.origin,
            uri: window.location.href,
            address: accounts[0],
            chainId: parseInt(chainId, 16),
            version: "1",
            nonce: Math.random().toString(36).slice(2),
            issuedAt: new Date().toISOString()
          };
          const challenge = await signChallenge(payload, chainNamespace);
          const encodedMessage = new TextEncoder().encode(challenge);
          const signedMessage = await this.provider.request({
            method: "signMessage",
            params: {
              message: encodedMessage,
              display: "utf8"
            }
          });
          const idToken = await verifySignedChallenge(chainNamespace, import_bs58.default.encode(signedMessage), challenge, this.name, this.sessionTime);
          saveToken(accounts[0], this.name, idToken);
          return {
            idToken
          };
        }
        throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
      }
      async disconnect() {
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.disconnectionError("Not connected with wallet");
        const accounts = await this.provider.request({
          method: "getAccounts"
        });
        if (accounts && accounts.length > 0) {
          clearToken(accounts[0], this.name);
        }
      }
    };
  }
});

export {
  BaseSolanaAdapter,
  init_baseSolanaAdapter_esm
};
//# sourceMappingURL=chunk-6B5OCUEX.js.map
