import {
  require_assert,
  require_bn,
  require_dist,
  require_elliptic,
  require_keccak,
  require_secp256k1
} from "./chunk-G3LXFHP3.js";
import {
  require_browser
} from "./chunk-SAXAG7U6.js";
import {
  __commonJS
} from "./chunk-JZQ37OGZ.js";

// ../node_modules/url/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../node_modules/url/node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// ../node_modules/url/util.js
var require_util = __commonJS({
  "../node_modules/url/util.js"(exports, module) {
    "use strict";
    module.exports = {
      isString: function(arg) {
        return typeof arg === "string";
      },
      isObject: function(arg) {
        return typeof arg === "object" && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
  }
});

// ../node_modules/querystring/decode.js
var require_decode = __commonJS({
  "../node_modules/querystring/decode.js"(exports, module) {
    "use strict";
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
      return obj;
    };
  }
});

// ../node_modules/querystring/encode.js
var require_encode = __commonJS({
  "../node_modules/querystring/encode.js"(exports, module) {
    "use strict";
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
  }
});

// ../node_modules/querystring/index.js
var require_querystring = __commonJS({
  "../node_modules/querystring/index.js"(exports) {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// ../node_modules/url/url.js
var require_url = __commonJS({
  "../node_modules/url/url.js"(exports) {
    "use strict";
    var punycode = require_punycode();
    var util = require_util();
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_querystring();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url)
        return url;
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (util.isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url))
        return Url.prototype.format.call(obj);
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol")
            result[rkey] = relative[rkey];
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
  }
});

// ../node_modules/is-hex-prefixed/src/index.js
var require_src = __commonJS({
  "../node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// ../node_modules/strip-hex-prefix/src/index.js
var require_src2 = __commonJS({
  "../node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    var isHexPrefixed = require_src();
    module.exports = function stripHexPrefix(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// ../node_modules/ethjs-util/lib/index.js
var require_lib = __commonJS({
  "../node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    var isHexPrefixed = require_src();
    var stripHexPrefix = require_src2();
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a + ", while padToEven.");
      }
      if (a.length % 2) {
        a = "0" + a;
      }
      return a;
    }
    function intToHex(i) {
      var hex = i.toString(16);
      return "0x" + hex;
    }
    function intToBuffer(i) {
      var hex = intToHex(i);
      return new Buffer(padToEven(hex.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex) {
      var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex) {
      var str = "";
      var i = 0, l = hex.length;
      if (hex.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex;
    }
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key + "'.");
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js
var require_secp256k1v3_lib = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BN = require_bn();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    exports.privateKeyExport = function(privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var d = new BN(privateKey);
      if (d.ucmp(ecparams.n) >= 0) {
        throw new Error("couldn't export to DER format");
      }
      var point = ec.g.mul(d);
      return toPublicKey(point.getX(), point.getY(), compressed);
    };
    exports.privateKeyModInverse = function(privateKey) {
      var bn = new BN(privateKey);
      if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
        throw new Error("private key range is invalid");
      }
      return bn.invm(ecparams.n).toArrayLike(Buffer, "be", 32);
    };
    exports.signatureImport = function(sigObj) {
      var r = new BN(sigObj.r);
      if (r.ucmp(ecparams.n) >= 0) {
        r = new BN(0);
      }
      var s = new BN(sigObj.s);
      if (s.ucmp(ecparams.n) >= 0) {
        s = new BN(0);
      }
      return Buffer.concat([r.toArrayLike(Buffer, "be", 32), s.toArrayLike(Buffer, "be", 32)]);
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var point = ec.keyFromPublic(publicKey);
      var scalar = new BN(privateKey);
      if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
        throw new Error("scalar was invalid (zero or overflow)");
      }
      var shared = point.pub.mul(scalar);
      return toPublicKey(shared.getX(), shared.getY(), compressed);
    };
    var toPublicKey = function(x, y, compressed) {
      var publicKey;
      if (compressed) {
        publicKey = Buffer.alloc(33);
        publicKey[0] = y.isOdd() ? 3 : 2;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
      } else {
        publicKey = Buffer.alloc(65);
        publicKey[0] = 4;
        x.toArrayLike(Buffer, "be", 32).copy(publicKey, 1);
        y.toArrayLike(Buffer, "be", 32).copy(publicKey, 33);
      }
      return publicKey;
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js
var require_der = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
      // begin
      48,
      129,
      211,
      2,
      1,
      1,
      4,
      32,
      // private key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // middle
      160,
      129,
      133,
      48,
      129,
      130,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      33,
      2,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      36,
      3,
      34,
      0,
      // public key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
      // begin
      48,
      130,
      1,
      19,
      2,
      1,
      1,
      4,
      32,
      // private key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // middle
      160,
      129,
      165,
      48,
      129,
      162,
      2,
      1,
      1,
      48,
      44,
      6,
      7,
      42,
      134,
      72,
      206,
      61,
      1,
      1,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      255,
      255,
      252,
      47,
      48,
      6,
      4,
      1,
      0,
      4,
      1,
      7,
      4,
      65,
      4,
      121,
      190,
      102,
      126,
      249,
      220,
      187,
      172,
      85,
      160,
      98,
      149,
      206,
      135,
      11,
      7,
      2,
      155,
      252,
      219,
      45,
      206,
      40,
      217,
      89,
      242,
      129,
      91,
      22,
      248,
      23,
      152,
      72,
      58,
      218,
      119,
      38,
      163,
      196,
      101,
      93,
      164,
      251,
      252,
      14,
      17,
      8,
      168,
      253,
      23,
      180,
      72,
      166,
      133,
      84,
      25,
      156,
      71,
      208,
      143,
      251,
      16,
      212,
      184,
      2,
      33,
      0,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      254,
      186,
      174,
      220,
      230,
      175,
      72,
      160,
      59,
      191,
      210,
      94,
      140,
      208,
      54,
      65,
      65,
      2,
      1,
      1,
      161,
      68,
      3,
      66,
      0,
      // public key
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.privateKeyExport = function(privateKey, publicKey, compressed) {
      if (compressed === void 0) {
        compressed = true;
      }
      var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
      privateKey.copy(result, compressed ? 8 : 9);
      publicKey.copy(result, compressed ? 181 : 214);
      return result;
    };
    exports.privateKeyImport = function(privateKey) {
      var length = privateKey.length;
      var index = 0;
      if (length < index + 1 || privateKey[index] !== 48)
        return null;
      index += 1;
      if (length < index + 1 || !(privateKey[index] & 128))
        return null;
      var lenb = privateKey[index] & 127;
      index += 1;
      if (lenb < 1 || lenb > 2)
        return null;
      if (length < index + lenb)
        return null;
      var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
      index += lenb;
      if (length < index + len)
        return null;
      if (length < index + 3 || privateKey[index] !== 2 || privateKey[index + 1] !== 1 || privateKey[index + 2] !== 1) {
        return null;
      }
      index += 3;
      if (length < index + 2 || privateKey[index] !== 4 || privateKey[index + 1] > 32 || length < index + 2 + privateKey[index + 1]) {
        return null;
      }
      return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
    };
    exports.signatureImportLax = function(signature) {
      var r = Buffer.alloc(32, 0);
      var s = Buffer.alloc(32, 0);
      var length = signature.length;
      var index = 0;
      if (signature[index++] !== 48) {
        return null;
      }
      var lenbyte = signature[index++];
      if (lenbyte & 128) {
        index += lenbyte - 128;
        if (index > length) {
          return null;
        }
      }
      if (signature[index++] !== 2) {
        return null;
      }
      var rlen = signature[index++];
      if (rlen & 128) {
        lenbyte = rlen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          rlen = (rlen << 8) + signature[index];
      }
      if (rlen > length - index) {
        return null;
      }
      var rindex = index;
      index += rlen;
      if (signature[index++] !== 2) {
        return null;
      }
      var slen = signature[index++];
      if (slen & 128) {
        lenbyte = slen - 128;
        if (index + lenbyte > length) {
          return null;
        }
        for (; lenbyte > 0 && signature[index] === 0; index += 1, lenbyte -= 1)
          ;
        for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)
          slen = (slen << 8) + signature[index];
      }
      if (slen > length - index) {
        return null;
      }
      var sindex = index;
      index += slen;
      for (; rlen > 0 && signature[rindex] === 0; rlen -= 1, rindex += 1)
        ;
      if (rlen > 32) {
        return null;
      }
      var rvalue = signature.slice(rindex, rindex + rlen);
      rvalue.copy(r, 32 - rvalue.length);
      for (; slen > 0 && signature[sindex] === 0; slen -= 1, sindex += 1)
        ;
      if (slen > 32) {
        return null;
      }
      var svalue = signature.slice(sindex, sindex + slen);
      svalue.copy(s, 32 - svalue.length);
      return { r, s };
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js
var require_secp256k1v3_adapter = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
    var secp256k1 = require_secp256k1();
    var secp256k1v3 = require_secp256k1v3_lib();
    var der = require_der();
    exports.privateKeyVerify = function(privateKey) {
      if (privateKey.length !== 32) {
        return false;
      }
      return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
    };
    exports.privateKeyExport = function(privateKey, compressed) {
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    };
    exports.privateKeyImport = function(privateKey) {
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {
        return privateKey;
      }
      throw new Error("couldn't import from DER format");
    };
    exports.privateKeyNegate = function(privateKey) {
      return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
    };
    exports.privateKeyModInverse = function(privateKey) {
      if (privateKey.length !== 32) {
        throw new Error("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
    };
    exports.privateKeyTweakAdd = function(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
    };
    exports.privateKeyTweakMul = function(privateKey, tweak) {
      return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
    };
    exports.publicKeyCreate = function(privateKey, compressed) {
      return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
    };
    exports.publicKeyConvert = function(publicKey, compressed) {
      return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
    };
    exports.publicKeyVerify = function(publicKey) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        return false;
      }
      return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
    };
    exports.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyTweakMul = function(publicKey, tweak, compressed) {
      return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
    };
    exports.publicKeyCombine = function(publicKeys, compressed) {
      var keys = [];
      publicKeys.forEach(function(publicKey) {
        keys.push(Uint8Array.from(publicKey));
      });
      return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
    };
    exports.signatureNormalize = function(signature) {
      return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
    };
    exports.signatureExport = function(signature) {
      return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
    };
    exports.signatureImport = function(signature) {
      return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
    };
    exports.signatureImportLax = function(signature) {
      if (signature.length === 0) {
        throw new RangeError("signature length is invalid");
      }
      var sigObj = der.signatureImportLax(signature);
      if (sigObj === null) {
        throw new Error("couldn't parse DER signature");
      }
      return secp256k1v3.signatureImport(sigObj);
    };
    exports.sign = function(message, privateKey, options) {
      if (options === null) {
        throw new TypeError("options should be an Object");
      }
      var signOptions = void 0;
      if (options) {
        signOptions = {};
        if (options.data === null) {
          throw new TypeError("options.data should be a Buffer");
        }
        if (options.data) {
          if (options.data.length != 32) {
            throw new RangeError("options.data length is invalid");
          }
          signOptions.data = new Uint8Array(options.data);
        }
        if (options.noncefn === null) {
          throw new TypeError("options.noncefn should be a Function");
        }
        if (options.noncefn) {
          signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
            var bufferAlgo = algo != null ? Buffer.from(algo) : null;
            var bufferData = data != null ? Buffer.from(data) : null;
            var buffer = Buffer.from("");
            if (options.noncefn) {
              buffer = options.noncefn(Buffer.from(message2), Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
            }
            return new Uint8Array(buffer);
          };
        }
      }
      var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
      return {
        signature: Buffer.from(sig.signature),
        recovery: sig.recid
      };
    };
    exports.verify = function(message, signature, publicKey) {
      return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
    };
    exports.recover = function(message, signature, recid, compressed) {
      return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
    };
    exports.ecdh = function(publicKey, privateKey) {
      return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
    };
    exports.ecdhUnsafe = function(publicKey, privateKey, compressed) {
      if (publicKey.length !== 33 && publicKey.length !== 65) {
        throw new RangeError("public key length is invalid");
      }
      if (privateKey.length !== 32) {
        throw new RangeError("private key length is invalid");
      }
      return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js
var require_constants = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
    var BN = require_bn();
    exports.MAX_INTEGER = new BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, "hex");
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, "hex");
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js
var require_bytes = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
    var ethjsUtil = require_lib();
    var BN = require_bn();
    exports.zeros = function(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    };
    exports.setLengthLeft = function(msg, length, right) {
      if (right === void 0) {
        right = false;
      }
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLength = exports.setLengthLeft;
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = function(a) {
      a = ethjsUtil.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.stripZeros = exports.unpad;
    exports.toBuffer = function(v) {
      if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer.from(v);
        } else if (typeof v === "string") {
          if (ethjsUtil.isHexString(v)) {
            v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), "hex");
          } else {
            throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
          }
        } else if (typeof v === "number") {
          v = ethjsUtil.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer.allocUnsafe(0);
        } else if (BN.isBN(v)) {
          v = v.toArrayLike(Buffer);
        } else if (v.toArray) {
          v = Buffer.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer.from(num.toTwos(256).toArray());
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return ethjsUtil.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.baToJSON = function(ba) {
      if (Buffer.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js
var require_hash = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
    var _a = require_keccak();
    var keccak224 = _a.keccak224;
    var keccak384 = _a.keccak384;
    var k256 = _a.keccak256;
    var keccak512 = _a.keccak512;
    var createHash = require_browser();
    var ethjsUtil = require_lib();
    var rlp = require_dist();
    var bytes_1 = require_bytes();
    exports.keccak = function(a, bits) {
      if (bits === void 0) {
        bits = 256;
      }
      if (typeof a === "string" && !ethjsUtil.isHexString(a)) {
        a = Buffer.from(a, "utf8");
      } else {
        a = bytes_1.toBuffer(a);
      }
      if (!bits)
        bits = 256;
      switch (bits) {
        case 224: {
          return keccak224(a);
        }
        case 256: {
          return k256(a);
        }
        case 384: {
          return keccak384(a);
        }
        case 512: {
          return keccak512(a);
        }
        default: {
          throw new Error("Invald algorithm: keccak" + bits);
        }
      }
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha256 = function(a) {
      a = bytes_1.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = bytes_1.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return bytes_1.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js
var require_account = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
    var assert = require_assert();
    var ethjsUtil = require_lib();
    var secp256k1 = require_secp256k1v3_adapter();
    var BN = require_bn();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash();
    exports.zeroAddress = function() {
      var addressLength = 20;
      var addr = bytes_1.zeros(addressLength);
      return bytes_1.bufferToHex(addr);
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddr = exports.zeroAddress();
      return zeroAddr === bytes_1.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address, eip1191ChainId) {
      address = ethjsUtil.stripHexPrefix(address).toLowerCase();
      var prefix = eip1191ChainId !== void 0 ? eip1191ChainId.toString() + "0x" : "";
      var hash = hash_1.keccak(prefix + address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address, eip1191ChainId) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = bytes_1.toBuffer(from);
      var nonceBN = new BN(nonce);
      if (nonceBN.isZero()) {
        return hash_1.rlphash([from, null]).slice(-20);
      }
      return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);
    };
    exports.generateAddress2 = function(from, salt, initCode) {
      var fromBuf = bytes_1.toBuffer(from);
      var saltBuf = bytes_1.toBuffer(salt);
      var initCodeBuf = bytes_1.toBuffer(initCode);
      assert(fromBuf.length === 20);
      assert(saltBuf.length === 32);
      var address = hash_1.keccak256(Buffer.concat([Buffer.from("ff", "hex"), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));
      return address.slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = bytes_1.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = function(pubKey, sanitize) {
      if (sanitize === void 0) {
        sanitize = false;
      }
      pubKey = bytes_1.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return hash_1.keccak(pubKey).slice(-20);
    };
    exports.publicToAddress = exports.pubToAddress;
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(exports.privateToPublic(privateKey));
    };
    exports.privateToPublic = function(privateKey) {
      privateKey = bytes_1.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = bytes_1.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js
var require_signature = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    var BN = require_bn();
    var bytes_1 = require_bytes();
    var hash_1 = require_hash();
    exports.ecsign = function(msgHash, privateKey, chainId) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var recovery = sig.recovery;
      var ret = {
        r: sig.signature.slice(0, 32),
        s: sig.signature.slice(32, 64),
        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
      };
      return ret;
    };
    exports.ecrecover = function(msgHash, v, r, s, chainId) {
      var signature = Buffer.concat([bytes_1.setLength(r, 32), bytes_1.setLength(s, 32)], 64);
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s, chainId) {
      var recovery = calculateSigRecovery(v, chainId);
      if (!isValidSigRecovery(recovery)) {
        throw new Error("Invalid signature v value");
      }
      return bytes_1.bufferToHex(Buffer.concat([bytes_1.setLengthLeft(r, 32), bytes_1.setLengthLeft(s, 32), bytes_1.toBuffer(v)]));
    };
    exports.fromRpcSig = function(sig) {
      var buf = bytes_1.toBuffer(sig);
      if (buf.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = buf[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: buf.slice(0, 32),
        s: buf.slice(32, 64)
      };
    };
    exports.isValidSignature = function(v, r, s, homesteadOrLater, chainId) {
      if (homesteadOrLater === void 0) {
        homesteadOrLater = true;
      }
      var SECP256K1_N_DIV_2 = new BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {
        return false;
      }
      var rBN = new BN(r);
      var sBN = new BN(s);
      if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
        return false;
      }
      if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = Buffer.from("Ethereum Signed Message:\n" + message.length.toString(), "utf-8");
      return hash_1.keccak(Buffer.concat([prefix, message]));
    };
    function calculateSigRecovery(v, chainId) {
      return chainId ? v - (2 * chainId + 35) : v - 27;
    }
    function isValidSigRecovery(recovery) {
      return recovery === 0 || recovery === 1;
    }
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js
var require_object = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = void 0;
    var assert = require_assert();
    var ethjsUtil = require_lib();
    var rlp = require_dist();
    var bytes_1 = require_bytes();
    exports.defineProperties = function(self, fields, data) {
      self.raw = [];
      self._fields = [];
      self.toJSON = function(label) {
        if (label === void 0) {
          label = false;
        }
        if (label) {
          var obj_1 = {};
          self._fields.forEach(function(field) {
            obj_1[field] = "0x" + self[field].toString("hex");
          });
          return obj_1;
        }
        return bytes_1.baToJSON(self.raw);
      };
      self.serialize = function serialize() {
        return rlp.encode(self.raw);
      };
      fields.forEach(function(field, i) {
        self._fields.push(field.name);
        function getter() {
          return self.raw[i];
        }
        function setter(v) {
          v = bytes_1.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = bytes_1.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer.from(ethjsUtil.stripHexPrefix(data), "hex");
        }
        if (Buffer.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self[self._fields[i]] = bytes_1.toBuffer(d);
          });
        } else if (typeof data === "object") {
          var keys_1 = Object.keys(data);
          fields.forEach(function(field) {
            if (keys_1.indexOf(field.name) !== -1)
              self[field.name] = data[field.name];
            if (keys_1.indexOf(field.alias) !== -1)
              self[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// ../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.secp256k1 = exports.rlp = exports.BN = void 0;
    var secp256k1 = require_secp256k1v3_adapter();
    exports.secp256k1 = secp256k1;
    var ethjsUtil = require_lib();
    var BN = require_bn();
    exports.BN = BN;
    var rlp = require_dist();
    exports.rlp = rlp;
    Object.assign(exports, ethjsUtil);
    __exportStar(require_constants(), exports);
    __exportStar(require_account(), exports);
    __exportStar(require_hash(), exports);
    __exportStar(require_signature(), exports);
    __exportStar(require_bytes(), exports);
    __exportStar(require_object(), exports);
  }
});

// ../node_modules/ethereumjs-abi/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/ethereumjs-abi/lib/index.js"(exports, module) {
    var utils = require_dist2();
    var BN = require_bn();
    var ABI = function() {
    };
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    ABI.eventID = function(name, types) {
      var sig = name + "(" + types.map(elementaryName).join(",") + ")";
      return utils.keccak256(Buffer.from(sig));
    };
    ABI.methodID = function(name, types) {
      return ABI.eventID(name, types).slice(0, 4);
    };
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
    }
    function parseTypeNxM(type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type = typeof arg;
      if (type === "string") {
        if (utils.isHexPrefixed(arg)) {
          return new BN(utils.stripHexPrefix(arg), 16);
        } else {
          return new BN(arg, 10);
        }
      } else if (type === "number") {
        return new BN(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function parseSignature(sig) {
      var tmp = /^(\w+)\((.*)\)$/.exec(sig);
      if (tmp.length !== 3) {
        throw new Error("Invalid method signature");
      }
      var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
      if (args !== null && args.length === 3) {
        return {
          method: tmp[1],
          args: args[1].split(","),
          retargs: args[2].split(",")
        };
      } else {
        var params = tmp[2].split(",");
        if (params.length === 1 && params[0] === "") {
          params = [];
        }
        return {
          method: tmp[1],
          args: params
        };
      }
    }
    function encodeSingle(type, arg) {
      var size, num, ret, i;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error("Elements exceed array size: " + size);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i in arg) {
          ret.push(encodeSingle(type, arg[i]));
        }
        if (size === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, utils.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(arg, 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type);
    }
    function decodeSingle(parsedType, data, offset) {
      if (typeof parsedType === "string") {
        parsedType = parseType(parsedType);
      }
      var size, num, ret, i;
      if (parsedType.name === "address") {
        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, "be", 20).toString("hex");
      } else if (parsedType.name === "bool") {
        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();
      } else if (parsedType.name === "string") {
        var bytes = decodeSingle(parsedType.rawType, data, offset);
        return Buffer.from(bytes, "utf8").toString();
      } else if (parsedType.isArray) {
        ret = [];
        size = parsedType.size;
        if (parsedType.size === "dynamic") {
          offset = decodeSingle("uint256", data, offset).toNumber();
          size = decodeSingle("uint256", data, offset).toNumber();
          offset = offset + 32;
        }
        for (i = 0; i < size; i++) {
          var decoded = decodeSingle(parsedType.subArray, data, offset);
          ret.push(decoded);
          offset += parsedType.subArray.memoryUsage;
        }
        return ret;
      } else if (parsedType.name === "bytes") {
        offset = decodeSingle("uint256", data, offset).toNumber();
        size = decodeSingle("uint256", data, offset).toNumber();
        return data.slice(offset + 32, offset + 32 + size);
      } else if (parsedType.name.startsWith("bytes")) {
        return data.slice(offset, offset + parsedType.size);
      } else if (parsedType.name.startsWith("uint")) {
        num = new BN(data.slice(offset, offset + 32), 16, "be");
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("int")) {
        num = new BN(data.slice(offset, offset + 32), 16, "be").fromTwos(256);
        if (num.bitLength() > parsedType.size) {
          throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
        }
        return num;
      } else if (parsedType.name.startsWith("ufixed")) {
        size = new BN(2).pow(new BN(parsedType.size[1]));
        num = decodeSingle("uint256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      } else if (parsedType.name.startsWith("fixed")) {
        size = new BN(2).pow(new BN(parsedType.size[1]));
        num = decodeSingle("int256", data, offset);
        if (!num.mod(size).isZero()) {
          throw new Error("Decimals not supported yet");
        }
        return num.div(size);
      }
      throw new Error("Unsupported or invalid type: " + parsedType.name);
    }
    function parseType(type) {
      var size;
      var ret;
      if (isArray(type)) {
        size = parseTypeArray(type);
        var subArray = type.slice(0, type.lastIndexOf("["));
        subArray = parseType(subArray);
        ret = {
          isArray: true,
          name: type,
          size,
          memoryUsage: size === "dynamic" ? 32 : subArray.memoryUsage * size,
          subArray
        };
        return ret;
      } else {
        var rawType;
        switch (type) {
          case "address":
            rawType = "uint160";
            break;
          case "bool":
            rawType = "uint8";
            break;
          case "string":
            rawType = "bytes";
            break;
        }
        ret = {
          rawType,
          name: type,
          memoryUsage: 32
        };
        if (type.startsWith("bytes") && type !== "bytes" || type.startsWith("uint") || type.startsWith("int")) {
          ret.size = parseTypeN(type);
        } else if (type.startsWith("ufixed") || type.startsWith("fixed")) {
          ret.size = parseTypeNxM(type);
        }
        if (type.startsWith("bytes") && type !== "bytes" && (ret.size < 1 || ret.size > 32)) {
          throw new Error("Invalid bytes<N> width: " + ret.size);
        }
        if ((type.startsWith("uint") || type.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
          throw new Error("Invalid int/uint<N> width: " + ret.size);
        }
        return ret;
      }
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    ABI.rawEncode = function(types, values) {
      var output = [];
      var data = [];
      var headLength = 0;
      types.forEach(function(type2) {
        if (isArray(type2)) {
          var size = parseTypeArray(type2);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];
        var cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    };
    ABI.rawDecode = function(types, data) {
      var ret = [];
      data = Buffer.from(data);
      var offset = 0;
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var parsed = parseType(type, data, offset);
        var decoded = decodeSingle(parsed, data, offset);
        offset += parsed.memoryUsage;
        ret.push(decoded);
      }
      return ret;
    };
    ABI.simpleEncode = function(method) {
      var args = Array.prototype.slice.call(arguments).slice(1);
      var sig = parseSignature(method);
      if (args.length !== sig.args.length) {
        throw new Error("Argument count mismatch");
      }
      return Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
    };
    ABI.simpleDecode = function(method, data) {
      var sig = parseSignature(method);
      if (!sig.retargs) {
        throw new Error("No return values in method");
      }
      return ABI.rawDecode(sig.retargs, data);
    };
    function stringify(type, value) {
      if (type.startsWith("address") || type.startsWith("bytes")) {
        return "0x" + value.toString("hex");
      } else {
        return value.toString();
      }
    }
    ABI.stringify = function(types, values) {
      var ret = [];
      for (var i in types) {
        var type = types[i];
        var value = values[i];
        if (/^[^\[]+\[.*\]$/.test(type)) {
          value = value.map(function(item) {
            return stringify(type, item);
          }).join(", ");
        } else {
          value = stringify(type, value);
        }
        ret.push(value);
      }
      return ret;
    };
    ABI.solidityHexValue = function(type, value, bitsize) {
      var size, num;
      if (isArray(type)) {
        var subType = type.replace(/\[.*?\]/, "");
        if (!isArray(subType)) {
          var arraySize = parseTypeArray(type);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error("Elements exceed array size: " + arraySize);
          }
        }
        var arrayValues = value.map(function(v) {
          return ABI.solidityHexValue(subType, v, 256);
        });
        return Buffer.concat(arrayValues);
      } else if (type === "bytes") {
        return value;
      } else if (type === "string") {
        return Buffer.from(value, "utf8");
      } else if (type === "bool") {
        bitsize = bitsize || 8;
        var padding = Array(bitsize / 4).join("0");
        return Buffer.from(value ? padding + "1" : padding + "0", "hex");
      } else if (type === "address") {
        var bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return utils.setLengthLeft(value, bytesize);
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error("Invalid bytes<N> width: " + size);
        }
        return utils.setLengthRight(value, size);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid uint<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied uint exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error("Invalid int<N> width: " + size);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error("Supplied int exceeds width: " + size + " vs " + num.bitLength());
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      } else {
        throw new Error("Unsupported or invalid type: " + type);
      }
    };
    ABI.solidityPack = function(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var ret = [];
      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];
        ret.push(ABI.solidityHexValue(type, value, null));
      }
      return Buffer.concat(ret);
    };
    ABI.soliditySHA3 = function(types, values) {
      return utils.keccak256(ABI.solidityPack(types, values));
    };
    ABI.soliditySHA256 = function(types, values) {
      return utils.sha256(ABI.solidityPack(types, values));
    };
    ABI.solidityRIPEMD160 = function(types, values) {
      return utils.ripemd160(ABI.solidityPack(types, values), true);
    };
    function isNumeric(c) {
      return c >= "0" && c <= "9";
    }
    ABI.fromSerpent = function(sig) {
      var ret = [];
      for (var i = 0; i < sig.length; i++) {
        var type = sig[i];
        if (type === "s") {
          ret.push("bytes");
        } else if (type === "b") {
          var tmp = "bytes";
          var j = i + 1;
          while (j < sig.length && isNumeric(sig[j])) {
            tmp += sig[j] - "0";
            j++;
          }
          i = j - 1;
          ret.push(tmp);
        } else if (type === "i") {
          ret.push("int256");
        } else if (type === "a") {
          ret.push("int256[]");
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return ret;
    };
    ABI.toSerpent = function(types) {
      var ret = [];
      for (var i = 0; i < types.length; i++) {
        var type = types[i];
        if (type === "bytes") {
          ret.push("s");
        } else if (type.startsWith("bytes")) {
          ret.push("b" + parseTypeN(type));
        } else if (type === "int256") {
          ret.push("i");
        } else if (type === "int256[]") {
          ret.push("a");
        } else {
          throw new Error("Unsupported or invalid type: " + type);
        }
      }
      return ret.join("");
    };
    module.exports = ABI;
  }
});

// ../node_modules/ethereumjs-abi/index.js
var require_ethereumjs_abi = __commonJS({
  "../node_modules/ethereumjs-abi/index.js"(exports, module) {
    module.exports = require_lib2();
  }
});

export {
  require_url,
  require_lib,
  require_ethereumjs_abi
};
/*! Bundled license information:

punycode/punycode.js:
  (*! https://mths.be/punycode v1.3.2 by @mathias *)
*/
//# sourceMappingURL=chunk-UJII67DZ.js.map
